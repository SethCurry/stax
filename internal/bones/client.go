// Code generated by ent, DO NOT EDIT.

package bones

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/SethCurry/stax/internal/bones/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/SethCurry/stax/internal/bones/artist"
	"github.com/SethCurry/stax/internal/bones/card"
	"github.com/SethCurry/stax/internal/bones/cardface"
	"github.com/SethCurry/stax/internal/bones/printing"
	"github.com/SethCurry/stax/internal/bones/printingimage"
	"github.com/SethCurry/stax/internal/bones/ruling"
	"github.com/SethCurry/stax/internal/bones/set"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artist is the client for interacting with the Artist builders.
	Artist *ArtistClient
	// Card is the client for interacting with the Card builders.
	Card *CardClient
	// CardFace is the client for interacting with the CardFace builders.
	CardFace *CardFaceClient
	// Printing is the client for interacting with the Printing builders.
	Printing *PrintingClient
	// PrintingImage is the client for interacting with the PrintingImage builders.
	PrintingImage *PrintingImageClient
	// Ruling is the client for interacting with the Ruling builders.
	Ruling *RulingClient
	// Set is the client for interacting with the Set builders.
	Set *SetClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artist = NewArtistClient(c.config)
	c.Card = NewCardClient(c.config)
	c.CardFace = NewCardFaceClient(c.config)
	c.Printing = NewPrintingClient(c.config)
	c.PrintingImage = NewPrintingImageClient(c.config)
	c.Ruling = NewRulingClient(c.config)
	c.Set = NewSetClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("bones: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("bones: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Artist:        NewArtistClient(cfg),
		Card:          NewCardClient(cfg),
		CardFace:      NewCardFaceClient(cfg),
		Printing:      NewPrintingClient(cfg),
		PrintingImage: NewPrintingImageClient(cfg),
		Ruling:        NewRulingClient(cfg),
		Set:           NewSetClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Artist:        NewArtistClient(cfg),
		Card:          NewCardClient(cfg),
		CardFace:      NewCardFaceClient(cfg),
		Printing:      NewPrintingClient(cfg),
		PrintingImage: NewPrintingImageClient(cfg),
		Ruling:        NewRulingClient(cfg),
		Set:           NewSetClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artist.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artist, c.Card, c.CardFace, c.Printing, c.PrintingImage, c.Ruling, c.Set,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artist, c.Card, c.CardFace, c.Printing, c.PrintingImage, c.Ruling, c.Set,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtistMutation:
		return c.Artist.mutate(ctx, m)
	case *CardMutation:
		return c.Card.mutate(ctx, m)
	case *CardFaceMutation:
		return c.CardFace.mutate(ctx, m)
	case *PrintingMutation:
		return c.Printing.mutate(ctx, m)
	case *PrintingImageMutation:
		return c.PrintingImage.mutate(ctx, m)
	case *RulingMutation:
		return c.Ruling.mutate(ctx, m)
	case *SetMutation:
		return c.Set.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("bones: unknown mutation type %T", m)
	}
}

// ArtistClient is a client for the Artist schema.
type ArtistClient struct {
	config
}

// NewArtistClient returns a client for the Artist from the given config.
func NewArtistClient(c config) *ArtistClient {
	return &ArtistClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artist.Hooks(f(g(h())))`.
func (c *ArtistClient) Use(hooks ...Hook) {
	c.hooks.Artist = append(c.hooks.Artist, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artist.Intercept(f(g(h())))`.
func (c *ArtistClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artist = append(c.inters.Artist, interceptors...)
}

// Create returns a builder for creating a Artist entity.
func (c *ArtistClient) Create() *ArtistCreate {
	mutation := newArtistMutation(c.config, OpCreate)
	return &ArtistCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artist entities.
func (c *ArtistClient) CreateBulk(builders ...*ArtistCreate) *ArtistCreateBulk {
	return &ArtistCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtistClient) MapCreateBulk(slice any, setFunc func(*ArtistCreate, int)) *ArtistCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtistCreateBulk{err: fmt.Errorf("calling to ArtistClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtistCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtistCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artist.
func (c *ArtistClient) Update() *ArtistUpdate {
	mutation := newArtistMutation(c.config, OpUpdate)
	return &ArtistUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtistClient) UpdateOne(a *Artist) *ArtistUpdateOne {
	mutation := newArtistMutation(c.config, OpUpdateOne, withArtist(a))
	return &ArtistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtistClient) UpdateOneID(id int) *ArtistUpdateOne {
	mutation := newArtistMutation(c.config, OpUpdateOne, withArtistID(id))
	return &ArtistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artist.
func (c *ArtistClient) Delete() *ArtistDelete {
	mutation := newArtistMutation(c.config, OpDelete)
	return &ArtistDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtistClient) DeleteOne(a *Artist) *ArtistDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtistClient) DeleteOneID(id int) *ArtistDeleteOne {
	builder := c.Delete().Where(artist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtistDeleteOne{builder}
}

// Query returns a query builder for Artist.
func (c *ArtistClient) Query() *ArtistQuery {
	return &ArtistQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtist},
		inters: c.Interceptors(),
	}
}

// Get returns a Artist entity by its id.
func (c *ArtistClient) Get(ctx context.Context, id int) (*Artist, error) {
	return c.Query().Where(artist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtistClient) GetX(ctx context.Context, id int) *Artist {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrintings queries the printings edge of a Artist.
func (c *ArtistClient) QueryPrintings(a *Artist) *PrintingQuery {
	query := (&PrintingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artist.Table, artist.FieldID, id),
			sqlgraph.To(printing.Table, printing.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artist.PrintingsTable, artist.PrintingsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtistClient) Hooks() []Hook {
	return c.hooks.Artist
}

// Interceptors returns the client interceptors.
func (c *ArtistClient) Interceptors() []Interceptor {
	return c.inters.Artist
}

func (c *ArtistClient) mutate(ctx context.Context, m *ArtistMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtistCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtistUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtistDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown Artist mutation op: %q", m.Op())
	}
}

// CardClient is a client for the Card schema.
type CardClient struct {
	config
}

// NewCardClient returns a client for the Card from the given config.
func NewCardClient(c config) *CardClient {
	return &CardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `card.Hooks(f(g(h())))`.
func (c *CardClient) Use(hooks ...Hook) {
	c.hooks.Card = append(c.hooks.Card, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `card.Intercept(f(g(h())))`.
func (c *CardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Card = append(c.inters.Card, interceptors...)
}

// Create returns a builder for creating a Card entity.
func (c *CardClient) Create() *CardCreate {
	mutation := newCardMutation(c.config, OpCreate)
	return &CardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Card entities.
func (c *CardClient) CreateBulk(builders ...*CardCreate) *CardCreateBulk {
	return &CardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CardClient) MapCreateBulk(slice any, setFunc func(*CardCreate, int)) *CardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CardCreateBulk{err: fmt.Errorf("calling to CardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Card.
func (c *CardClient) Update() *CardUpdate {
	mutation := newCardMutation(c.config, OpUpdate)
	return &CardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CardClient) UpdateOne(ca *Card) *CardUpdateOne {
	mutation := newCardMutation(c.config, OpUpdateOne, withCard(ca))
	return &CardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CardClient) UpdateOneID(id int) *CardUpdateOne {
	mutation := newCardMutation(c.config, OpUpdateOne, withCardID(id))
	return &CardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Card.
func (c *CardClient) Delete() *CardDelete {
	mutation := newCardMutation(c.config, OpDelete)
	return &CardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CardClient) DeleteOne(ca *Card) *CardDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CardClient) DeleteOneID(id int) *CardDeleteOne {
	builder := c.Delete().Where(card.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CardDeleteOne{builder}
}

// Query returns a query builder for Card.
func (c *CardClient) Query() *CardQuery {
	return &CardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCard},
		inters: c.Interceptors(),
	}
}

// Get returns a Card entity by its id.
func (c *CardClient) Get(ctx context.Context, id int) (*Card, error) {
	return c.Query().Where(card.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CardClient) GetX(ctx context.Context, id int) *Card {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFaces queries the faces edge of a Card.
func (c *CardClient) QueryFaces(ca *Card) *CardFaceQuery {
	query := (&CardFaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(card.Table, card.FieldID, id),
			sqlgraph.To(cardface.Table, cardface.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, card.FacesTable, card.FacesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRulings queries the rulings edge of a Card.
func (c *CardClient) QueryRulings(ca *Card) *RulingQuery {
	query := (&RulingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(card.Table, card.FieldID, id),
			sqlgraph.To(ruling.Table, ruling.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, card.RulingsTable, card.RulingsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CardClient) Hooks() []Hook {
	return c.hooks.Card
}

// Interceptors returns the client interceptors.
func (c *CardClient) Interceptors() []Interceptor {
	return c.inters.Card
}

func (c *CardClient) mutate(ctx context.Context, m *CardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown Card mutation op: %q", m.Op())
	}
}

// CardFaceClient is a client for the CardFace schema.
type CardFaceClient struct {
	config
}

// NewCardFaceClient returns a client for the CardFace from the given config.
func NewCardFaceClient(c config) *CardFaceClient {
	return &CardFaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cardface.Hooks(f(g(h())))`.
func (c *CardFaceClient) Use(hooks ...Hook) {
	c.hooks.CardFace = append(c.hooks.CardFace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cardface.Intercept(f(g(h())))`.
func (c *CardFaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.CardFace = append(c.inters.CardFace, interceptors...)
}

// Create returns a builder for creating a CardFace entity.
func (c *CardFaceClient) Create() *CardFaceCreate {
	mutation := newCardFaceMutation(c.config, OpCreate)
	return &CardFaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CardFace entities.
func (c *CardFaceClient) CreateBulk(builders ...*CardFaceCreate) *CardFaceCreateBulk {
	return &CardFaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CardFaceClient) MapCreateBulk(slice any, setFunc func(*CardFaceCreate, int)) *CardFaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CardFaceCreateBulk{err: fmt.Errorf("calling to CardFaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CardFaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CardFaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CardFace.
func (c *CardFaceClient) Update() *CardFaceUpdate {
	mutation := newCardFaceMutation(c.config, OpUpdate)
	return &CardFaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CardFaceClient) UpdateOne(cf *CardFace) *CardFaceUpdateOne {
	mutation := newCardFaceMutation(c.config, OpUpdateOne, withCardFace(cf))
	return &CardFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CardFaceClient) UpdateOneID(id int) *CardFaceUpdateOne {
	mutation := newCardFaceMutation(c.config, OpUpdateOne, withCardFaceID(id))
	return &CardFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CardFace.
func (c *CardFaceClient) Delete() *CardFaceDelete {
	mutation := newCardFaceMutation(c.config, OpDelete)
	return &CardFaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CardFaceClient) DeleteOne(cf *CardFace) *CardFaceDeleteOne {
	return c.DeleteOneID(cf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CardFaceClient) DeleteOneID(id int) *CardFaceDeleteOne {
	builder := c.Delete().Where(cardface.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CardFaceDeleteOne{builder}
}

// Query returns a query builder for CardFace.
func (c *CardFaceClient) Query() *CardFaceQuery {
	return &CardFaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCardFace},
		inters: c.Interceptors(),
	}
}

// Get returns a CardFace entity by its id.
func (c *CardFaceClient) Get(ctx context.Context, id int) (*CardFace, error) {
	return c.Query().Where(cardface.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CardFaceClient) GetX(ctx context.Context, id int) *CardFace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCard queries the card edge of a CardFace.
func (c *CardFaceClient) QueryCard(cf *CardFace) *CardQuery {
	query := (&CardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cardface.Table, cardface.FieldID, id),
			sqlgraph.To(card.Table, card.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, cardface.CardTable, cardface.CardColumn),
		)
		fromV = sqlgraph.Neighbors(cf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrintings queries the printings edge of a CardFace.
func (c *CardFaceClient) QueryPrintings(cf *CardFace) *PrintingQuery {
	query := (&PrintingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cardface.Table, cardface.FieldID, id),
			sqlgraph.To(printing.Table, printing.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, cardface.PrintingsTable, cardface.PrintingsColumn),
		)
		fromV = sqlgraph.Neighbors(cf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CardFaceClient) Hooks() []Hook {
	return c.hooks.CardFace
}

// Interceptors returns the client interceptors.
func (c *CardFaceClient) Interceptors() []Interceptor {
	return c.inters.CardFace
}

func (c *CardFaceClient) mutate(ctx context.Context, m *CardFaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CardFaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CardFaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CardFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CardFaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown CardFace mutation op: %q", m.Op())
	}
}

// PrintingClient is a client for the Printing schema.
type PrintingClient struct {
	config
}

// NewPrintingClient returns a client for the Printing from the given config.
func NewPrintingClient(c config) *PrintingClient {
	return &PrintingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `printing.Hooks(f(g(h())))`.
func (c *PrintingClient) Use(hooks ...Hook) {
	c.hooks.Printing = append(c.hooks.Printing, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `printing.Intercept(f(g(h())))`.
func (c *PrintingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Printing = append(c.inters.Printing, interceptors...)
}

// Create returns a builder for creating a Printing entity.
func (c *PrintingClient) Create() *PrintingCreate {
	mutation := newPrintingMutation(c.config, OpCreate)
	return &PrintingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Printing entities.
func (c *PrintingClient) CreateBulk(builders ...*PrintingCreate) *PrintingCreateBulk {
	return &PrintingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrintingClient) MapCreateBulk(slice any, setFunc func(*PrintingCreate, int)) *PrintingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrintingCreateBulk{err: fmt.Errorf("calling to PrintingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrintingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrintingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Printing.
func (c *PrintingClient) Update() *PrintingUpdate {
	mutation := newPrintingMutation(c.config, OpUpdate)
	return &PrintingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrintingClient) UpdateOne(pr *Printing) *PrintingUpdateOne {
	mutation := newPrintingMutation(c.config, OpUpdateOne, withPrinting(pr))
	return &PrintingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrintingClient) UpdateOneID(id int) *PrintingUpdateOne {
	mutation := newPrintingMutation(c.config, OpUpdateOne, withPrintingID(id))
	return &PrintingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Printing.
func (c *PrintingClient) Delete() *PrintingDelete {
	mutation := newPrintingMutation(c.config, OpDelete)
	return &PrintingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrintingClient) DeleteOne(pr *Printing) *PrintingDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrintingClient) DeleteOneID(id int) *PrintingDeleteOne {
	builder := c.Delete().Where(printing.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrintingDeleteOne{builder}
}

// Query returns a query builder for Printing.
func (c *PrintingClient) Query() *PrintingQuery {
	return &PrintingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrinting},
		inters: c.Interceptors(),
	}
}

// Get returns a Printing entity by its id.
func (c *PrintingClient) Get(ctx context.Context, id int) (*Printing, error) {
	return c.Query().Where(printing.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrintingClient) GetX(ctx context.Context, id int) *Printing {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtist queries the artist edge of a Printing.
func (c *PrintingClient) QueryArtist(pr *Printing) *ArtistQuery {
	query := (&ArtistClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printing.Table, printing.FieldID, id),
			sqlgraph.To(artist.Table, artist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, printing.ArtistTable, printing.ArtistColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySet queries the set edge of a Printing.
func (c *PrintingClient) QuerySet(pr *Printing) *SetQuery {
	query := (&SetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printing.Table, printing.FieldID, id),
			sqlgraph.To(set.Table, set.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, printing.SetTable, printing.SetColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCardFace queries the card_face edge of a Printing.
func (c *PrintingClient) QueryCardFace(pr *Printing) *CardFaceQuery {
	query := (&CardFaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printing.Table, printing.FieldID, id),
			sqlgraph.To(cardface.Table, cardface.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, printing.CardFaceTable, printing.CardFaceColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a Printing.
func (c *PrintingClient) QueryImages(pr *Printing) *PrintingImageQuery {
	query := (&PrintingImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printing.Table, printing.FieldID, id),
			sqlgraph.To(printingimage.Table, printingimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, printing.ImagesTable, printing.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrintingClient) Hooks() []Hook {
	return c.hooks.Printing
}

// Interceptors returns the client interceptors.
func (c *PrintingClient) Interceptors() []Interceptor {
	return c.inters.Printing
}

func (c *PrintingClient) mutate(ctx context.Context, m *PrintingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrintingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrintingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrintingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrintingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown Printing mutation op: %q", m.Op())
	}
}

// PrintingImageClient is a client for the PrintingImage schema.
type PrintingImageClient struct {
	config
}

// NewPrintingImageClient returns a client for the PrintingImage from the given config.
func NewPrintingImageClient(c config) *PrintingImageClient {
	return &PrintingImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `printingimage.Hooks(f(g(h())))`.
func (c *PrintingImageClient) Use(hooks ...Hook) {
	c.hooks.PrintingImage = append(c.hooks.PrintingImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `printingimage.Intercept(f(g(h())))`.
func (c *PrintingImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.PrintingImage = append(c.inters.PrintingImage, interceptors...)
}

// Create returns a builder for creating a PrintingImage entity.
func (c *PrintingImageClient) Create() *PrintingImageCreate {
	mutation := newPrintingImageMutation(c.config, OpCreate)
	return &PrintingImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PrintingImage entities.
func (c *PrintingImageClient) CreateBulk(builders ...*PrintingImageCreate) *PrintingImageCreateBulk {
	return &PrintingImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrintingImageClient) MapCreateBulk(slice any, setFunc func(*PrintingImageCreate, int)) *PrintingImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrintingImageCreateBulk{err: fmt.Errorf("calling to PrintingImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrintingImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrintingImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PrintingImage.
func (c *PrintingImageClient) Update() *PrintingImageUpdate {
	mutation := newPrintingImageMutation(c.config, OpUpdate)
	return &PrintingImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrintingImageClient) UpdateOne(pi *PrintingImage) *PrintingImageUpdateOne {
	mutation := newPrintingImageMutation(c.config, OpUpdateOne, withPrintingImage(pi))
	return &PrintingImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrintingImageClient) UpdateOneID(id int) *PrintingImageUpdateOne {
	mutation := newPrintingImageMutation(c.config, OpUpdateOne, withPrintingImageID(id))
	return &PrintingImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PrintingImage.
func (c *PrintingImageClient) Delete() *PrintingImageDelete {
	mutation := newPrintingImageMutation(c.config, OpDelete)
	return &PrintingImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrintingImageClient) DeleteOne(pi *PrintingImage) *PrintingImageDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrintingImageClient) DeleteOneID(id int) *PrintingImageDeleteOne {
	builder := c.Delete().Where(printingimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrintingImageDeleteOne{builder}
}

// Query returns a query builder for PrintingImage.
func (c *PrintingImageClient) Query() *PrintingImageQuery {
	return &PrintingImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrintingImage},
		inters: c.Interceptors(),
	}
}

// Get returns a PrintingImage entity by its id.
func (c *PrintingImageClient) Get(ctx context.Context, id int) (*PrintingImage, error) {
	return c.Query().Where(printingimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrintingImageClient) GetX(ctx context.Context, id int) *PrintingImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrinting queries the printing edge of a PrintingImage.
func (c *PrintingImageClient) QueryPrinting(pi *PrintingImage) *PrintingQuery {
	query := (&PrintingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printingimage.Table, printingimage.FieldID, id),
			sqlgraph.To(printing.Table, printing.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, printingimage.PrintingTable, printingimage.PrintingColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrintingImageClient) Hooks() []Hook {
	return c.hooks.PrintingImage
}

// Interceptors returns the client interceptors.
func (c *PrintingImageClient) Interceptors() []Interceptor {
	return c.inters.PrintingImage
}

func (c *PrintingImageClient) mutate(ctx context.Context, m *PrintingImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrintingImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrintingImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrintingImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrintingImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown PrintingImage mutation op: %q", m.Op())
	}
}

// RulingClient is a client for the Ruling schema.
type RulingClient struct {
	config
}

// NewRulingClient returns a client for the Ruling from the given config.
func NewRulingClient(c config) *RulingClient {
	return &RulingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ruling.Hooks(f(g(h())))`.
func (c *RulingClient) Use(hooks ...Hook) {
	c.hooks.Ruling = append(c.hooks.Ruling, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ruling.Intercept(f(g(h())))`.
func (c *RulingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ruling = append(c.inters.Ruling, interceptors...)
}

// Create returns a builder for creating a Ruling entity.
func (c *RulingClient) Create() *RulingCreate {
	mutation := newRulingMutation(c.config, OpCreate)
	return &RulingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ruling entities.
func (c *RulingClient) CreateBulk(builders ...*RulingCreate) *RulingCreateBulk {
	return &RulingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RulingClient) MapCreateBulk(slice any, setFunc func(*RulingCreate, int)) *RulingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RulingCreateBulk{err: fmt.Errorf("calling to RulingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RulingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RulingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ruling.
func (c *RulingClient) Update() *RulingUpdate {
	mutation := newRulingMutation(c.config, OpUpdate)
	return &RulingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RulingClient) UpdateOne(r *Ruling) *RulingUpdateOne {
	mutation := newRulingMutation(c.config, OpUpdateOne, withRuling(r))
	return &RulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RulingClient) UpdateOneID(id int) *RulingUpdateOne {
	mutation := newRulingMutation(c.config, OpUpdateOne, withRulingID(id))
	return &RulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ruling.
func (c *RulingClient) Delete() *RulingDelete {
	mutation := newRulingMutation(c.config, OpDelete)
	return &RulingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RulingClient) DeleteOne(r *Ruling) *RulingDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RulingClient) DeleteOneID(id int) *RulingDeleteOne {
	builder := c.Delete().Where(ruling.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RulingDeleteOne{builder}
}

// Query returns a query builder for Ruling.
func (c *RulingClient) Query() *RulingQuery {
	return &RulingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRuling},
		inters: c.Interceptors(),
	}
}

// Get returns a Ruling entity by its id.
func (c *RulingClient) Get(ctx context.Context, id int) (*Ruling, error) {
	return c.Query().Where(ruling.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RulingClient) GetX(ctx context.Context, id int) *Ruling {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCard queries the card edge of a Ruling.
func (c *RulingClient) QueryCard(r *Ruling) *CardQuery {
	query := (&CardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ruling.Table, ruling.FieldID, id),
			sqlgraph.To(card.Table, card.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, ruling.CardTable, ruling.CardColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RulingClient) Hooks() []Hook {
	return c.hooks.Ruling
}

// Interceptors returns the client interceptors.
func (c *RulingClient) Interceptors() []Interceptor {
	return c.inters.Ruling
}

func (c *RulingClient) mutate(ctx context.Context, m *RulingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RulingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RulingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RulingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown Ruling mutation op: %q", m.Op())
	}
}

// SetClient is a client for the Set schema.
type SetClient struct {
	config
}

// NewSetClient returns a client for the Set from the given config.
func NewSetClient(c config) *SetClient {
	return &SetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `set.Hooks(f(g(h())))`.
func (c *SetClient) Use(hooks ...Hook) {
	c.hooks.Set = append(c.hooks.Set, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `set.Intercept(f(g(h())))`.
func (c *SetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Set = append(c.inters.Set, interceptors...)
}

// Create returns a builder for creating a Set entity.
func (c *SetClient) Create() *SetCreate {
	mutation := newSetMutation(c.config, OpCreate)
	return &SetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Set entities.
func (c *SetClient) CreateBulk(builders ...*SetCreate) *SetCreateBulk {
	return &SetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SetClient) MapCreateBulk(slice any, setFunc func(*SetCreate, int)) *SetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SetCreateBulk{err: fmt.Errorf("calling to SetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Set.
func (c *SetClient) Update() *SetUpdate {
	mutation := newSetMutation(c.config, OpUpdate)
	return &SetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SetClient) UpdateOne(s *Set) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSet(s))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SetClient) UpdateOneID(id int) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSetID(id))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Set.
func (c *SetClient) Delete() *SetDelete {
	mutation := newSetMutation(c.config, OpDelete)
	return &SetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SetClient) DeleteOne(s *Set) *SetDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SetClient) DeleteOneID(id int) *SetDeleteOne {
	builder := c.Delete().Where(set.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SetDeleteOne{builder}
}

// Query returns a query builder for Set.
func (c *SetClient) Query() *SetQuery {
	return &SetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSet},
		inters: c.Interceptors(),
	}
}

// Get returns a Set entity by its id.
func (c *SetClient) Get(ctx context.Context, id int) (*Set, error) {
	return c.Query().Where(set.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SetClient) GetX(ctx context.Context, id int) *Set {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrintings queries the printings edge of a Set.
func (c *SetClient) QueryPrintings(s *Set) *PrintingQuery {
	query := (&PrintingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(set.Table, set.FieldID, id),
			sqlgraph.To(printing.Table, printing.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, set.PrintingsTable, set.PrintingsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SetClient) Hooks() []Hook {
	return c.hooks.Set
}

// Interceptors returns the client interceptors.
func (c *SetClient) Interceptors() []Interceptor {
	return c.inters.Set
}

func (c *SetClient) mutate(ctx context.Context, m *SetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("bones: unknown Set mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artist, Card, CardFace, Printing, PrintingImage, Ruling, Set []ent.Hook
	}
	inters struct {
		Artist, Card, CardFace, Printing, PrintingImage, Ruling, Set []ent.Interceptor
	}
)
