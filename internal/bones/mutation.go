// Code generated by ent, DO NOT EDIT.

package bones

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/SethCurry/stax/internal/bones/artist"
	"github.com/SethCurry/stax/internal/bones/card"
	"github.com/SethCurry/stax/internal/bones/cardface"
	"github.com/SethCurry/stax/internal/bones/predicate"
	"github.com/SethCurry/stax/internal/bones/printing"
	"github.com/SethCurry/stax/internal/bones/printingimage"
	"github.com/SethCurry/stax/internal/bones/ruling"
	"github.com/SethCurry/stax/internal/bones/set"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtist        = "Artist"
	TypeCard          = "Card"
	TypeCardFace      = "CardFace"
	TypePrinting      = "Printing"
	TypePrintingImage = "PrintingImage"
	TypeRuling        = "Ruling"
	TypeSet           = "Set"
)

// ArtistMutation represents an operation that mutates the Artist nodes in the graph.
type ArtistMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	printings        map[int]struct{}
	removedprintings map[int]struct{}
	clearedprintings bool
	done             bool
	oldValue         func(context.Context) (*Artist, error)
	predicates       []predicate.Artist
}

var _ ent.Mutation = (*ArtistMutation)(nil)

// artistOption allows management of the mutation configuration using functional options.
type artistOption func(*ArtistMutation)

// newArtistMutation creates new mutation for the Artist entity.
func newArtistMutation(c config, op Op, opts ...artistOption) *ArtistMutation {
	m := &ArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtistID sets the ID field of the mutation.
func withArtistID(id int) artistOption {
	return func(m *ArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *Artist
		)
		m.oldValue = func(ctx context.Context) (*Artist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtist sets the old Artist of the mutation.
func withArtist(node *Artist) artistOption {
	return func(m *ArtistMutation) {
		m.oldValue = func(context.Context) (*Artist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtistMutation) ResetName() {
	m.name = nil
}

// AddPrintingIDs adds the "printings" edge to the Printing entity by ids.
func (m *ArtistMutation) AddPrintingIDs(ids ...int) {
	if m.printings == nil {
		m.printings = make(map[int]struct{})
	}
	for i := range ids {
		m.printings[ids[i]] = struct{}{}
	}
}

// ClearPrintings clears the "printings" edge to the Printing entity.
func (m *ArtistMutation) ClearPrintings() {
	m.clearedprintings = true
}

// PrintingsCleared reports if the "printings" edge to the Printing entity was cleared.
func (m *ArtistMutation) PrintingsCleared() bool {
	return m.clearedprintings
}

// RemovePrintingIDs removes the "printings" edge to the Printing entity by IDs.
func (m *ArtistMutation) RemovePrintingIDs(ids ...int) {
	if m.removedprintings == nil {
		m.removedprintings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.printings, ids[i])
		m.removedprintings[ids[i]] = struct{}{}
	}
}

// RemovedPrintings returns the removed IDs of the "printings" edge to the Printing entity.
func (m *ArtistMutation) RemovedPrintingsIDs() (ids []int) {
	for id := range m.removedprintings {
		ids = append(ids, id)
	}
	return
}

// PrintingsIDs returns the "printings" edge IDs in the mutation.
func (m *ArtistMutation) PrintingsIDs() (ids []int) {
	for id := range m.printings {
		ids = append(ids, id)
	}
	return
}

// ResetPrintings resets all changes to the "printings" edge.
func (m *ArtistMutation) ResetPrintings() {
	m.printings = nil
	m.clearedprintings = false
	m.removedprintings = nil
}

// Where appends a list predicates to the ArtistMutation builder.
func (m *ArtistMutation) Where(ps ...predicate.Artist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artist).
func (m *ArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtistMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, artist.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artist.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artist.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Artist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtistMutation) ResetField(name string) error {
	switch name {
	case artist.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.printings != nil {
		edges = append(edges, artist.EdgePrintings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.printings))
		for id := range m.printings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprintings != nil {
		edges = append(edges, artist.EdgePrintings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.removedprintings))
		for id := range m.removedprintings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprintings {
		edges = append(edges, artist.EdgePrintings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case artist.EdgePrintings:
		return m.clearedprintings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtistMutation) ResetEdge(name string) error {
	switch name {
	case artist.EdgePrintings:
		m.ResetPrintings()
		return nil
	}
	return fmt.Errorf("unknown Artist edge %s", name)
}

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	oracle_id         *string
	color_identity    *uint8
	addcolor_identity *int8
	clearedFields     map[string]struct{}
	faces             map[int]struct{}
	removedfaces      map[int]struct{}
	clearedfaces      bool
	rulings           map[int]struct{}
	removedrulings    map[int]struct{}
	clearedrulings    bool
	done              bool
	oldValue          func(context.Context) (*Card, error)
	predicates        []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id int) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CardMutation) ResetName() {
	m.name = nil
}

// SetOracleID sets the "oracle_id" field.
func (m *CardMutation) SetOracleID(s string) {
	m.oracle_id = &s
}

// OracleID returns the value of the "oracle_id" field in the mutation.
func (m *CardMutation) OracleID() (r string, exists bool) {
	v := m.oracle_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOracleID returns the old "oracle_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldOracleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOracleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOracleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOracleID: %w", err)
	}
	return oldValue.OracleID, nil
}

// ResetOracleID resets all changes to the "oracle_id" field.
func (m *CardMutation) ResetOracleID() {
	m.oracle_id = nil
}

// SetColorIdentity sets the "color_identity" field.
func (m *CardMutation) SetColorIdentity(u uint8) {
	m.color_identity = &u
	m.addcolor_identity = nil
}

// ColorIdentity returns the value of the "color_identity" field in the mutation.
func (m *CardMutation) ColorIdentity() (r uint8, exists bool) {
	v := m.color_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldColorIdentity returns the old "color_identity" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldColorIdentity(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorIdentity: %w", err)
	}
	return oldValue.ColorIdentity, nil
}

// AddColorIdentity adds u to the "color_identity" field.
func (m *CardMutation) AddColorIdentity(u int8) {
	if m.addcolor_identity != nil {
		*m.addcolor_identity += u
	} else {
		m.addcolor_identity = &u
	}
}

// AddedColorIdentity returns the value that was added to the "color_identity" field in this mutation.
func (m *CardMutation) AddedColorIdentity() (r int8, exists bool) {
	v := m.addcolor_identity
	if v == nil {
		return
	}
	return *v, true
}

// ResetColorIdentity resets all changes to the "color_identity" field.
func (m *CardMutation) ResetColorIdentity() {
	m.color_identity = nil
	m.addcolor_identity = nil
}

// AddFaceIDs adds the "faces" edge to the CardFace entity by ids.
func (m *CardMutation) AddFaceIDs(ids ...int) {
	if m.faces == nil {
		m.faces = make(map[int]struct{})
	}
	for i := range ids {
		m.faces[ids[i]] = struct{}{}
	}
}

// ClearFaces clears the "faces" edge to the CardFace entity.
func (m *CardMutation) ClearFaces() {
	m.clearedfaces = true
}

// FacesCleared reports if the "faces" edge to the CardFace entity was cleared.
func (m *CardMutation) FacesCleared() bool {
	return m.clearedfaces
}

// RemoveFaceIDs removes the "faces" edge to the CardFace entity by IDs.
func (m *CardMutation) RemoveFaceIDs(ids ...int) {
	if m.removedfaces == nil {
		m.removedfaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.faces, ids[i])
		m.removedfaces[ids[i]] = struct{}{}
	}
}

// RemovedFaces returns the removed IDs of the "faces" edge to the CardFace entity.
func (m *CardMutation) RemovedFacesIDs() (ids []int) {
	for id := range m.removedfaces {
		ids = append(ids, id)
	}
	return
}

// FacesIDs returns the "faces" edge IDs in the mutation.
func (m *CardMutation) FacesIDs() (ids []int) {
	for id := range m.faces {
		ids = append(ids, id)
	}
	return
}

// ResetFaces resets all changes to the "faces" edge.
func (m *CardMutation) ResetFaces() {
	m.faces = nil
	m.clearedfaces = false
	m.removedfaces = nil
}

// AddRulingIDs adds the "rulings" edge to the Ruling entity by ids.
func (m *CardMutation) AddRulingIDs(ids ...int) {
	if m.rulings == nil {
		m.rulings = make(map[int]struct{})
	}
	for i := range ids {
		m.rulings[ids[i]] = struct{}{}
	}
}

// ClearRulings clears the "rulings" edge to the Ruling entity.
func (m *CardMutation) ClearRulings() {
	m.clearedrulings = true
}

// RulingsCleared reports if the "rulings" edge to the Ruling entity was cleared.
func (m *CardMutation) RulingsCleared() bool {
	return m.clearedrulings
}

// RemoveRulingIDs removes the "rulings" edge to the Ruling entity by IDs.
func (m *CardMutation) RemoveRulingIDs(ids ...int) {
	if m.removedrulings == nil {
		m.removedrulings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rulings, ids[i])
		m.removedrulings[ids[i]] = struct{}{}
	}
}

// RemovedRulings returns the removed IDs of the "rulings" edge to the Ruling entity.
func (m *CardMutation) RemovedRulingsIDs() (ids []int) {
	for id := range m.removedrulings {
		ids = append(ids, id)
	}
	return
}

// RulingsIDs returns the "rulings" edge IDs in the mutation.
func (m *CardMutation) RulingsIDs() (ids []int) {
	for id := range m.rulings {
		ids = append(ids, id)
	}
	return
}

// ResetRulings resets all changes to the "rulings" edge.
func (m *CardMutation) ResetRulings() {
	m.rulings = nil
	m.clearedrulings = false
	m.removedrulings = nil
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Card, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, card.FieldName)
	}
	if m.oracle_id != nil {
		fields = append(fields, card.FieldOracleID)
	}
	if m.color_identity != nil {
		fields = append(fields, card.FieldColorIdentity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldName:
		return m.Name()
	case card.FieldOracleID:
		return m.OracleID()
	case card.FieldColorIdentity:
		return m.ColorIdentity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldName:
		return m.OldName(ctx)
	case card.FieldOracleID:
		return m.OldOracleID(ctx)
	case card.FieldColorIdentity:
		return m.OldColorIdentity(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case card.FieldOracleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOracleID(v)
		return nil
	case card.FieldColorIdentity:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	if m.addcolor_identity != nil {
		fields = append(fields, card.FieldColorIdentity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case card.FieldColorIdentity:
		return m.AddedColorIdentity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case card.FieldColorIdentity:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColorIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldName:
		m.ResetName()
		return nil
	case card.FieldOracleID:
		m.ResetOracleID()
		return nil
	case card.FieldColorIdentity:
		m.ResetColorIdentity()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.faces != nil {
		edges = append(edges, card.EdgeFaces)
	}
	if m.rulings != nil {
		edges = append(edges, card.EdgeRulings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeFaces:
		ids := make([]ent.Value, 0, len(m.faces))
		for id := range m.faces {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeRulings:
		ids := make([]ent.Value, 0, len(m.rulings))
		for id := range m.rulings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfaces != nil {
		edges = append(edges, card.EdgeFaces)
	}
	if m.removedrulings != nil {
		edges = append(edges, card.EdgeRulings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeFaces:
		ids := make([]ent.Value, 0, len(m.removedfaces))
		for id := range m.removedfaces {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeRulings:
		ids := make([]ent.Value, 0, len(m.removedrulings))
		for id := range m.removedrulings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfaces {
		edges = append(edges, card.EdgeFaces)
	}
	if m.clearedrulings {
		edges = append(edges, card.EdgeRulings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeFaces:
		return m.clearedfaces
	case card.EdgeRulings:
		return m.clearedrulings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeFaces:
		m.ResetFaces()
		return nil
	case card.EdgeRulings:
		m.ResetRulings()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// CardFaceMutation represents an operation that mutates the CardFace nodes in the graph.
type CardFaceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	flavor_text      *string
	oracle_text      *string
	language         *string
	cmc              *float32
	addcmc           *float32
	power            *string
	toughness        *string
	loyalty          *string
	mana_cost        *string
	type_line        *string
	colors           *string
	clearedFields    map[string]struct{}
	card             *int
	clearedcard      bool
	printings        map[int]struct{}
	removedprintings map[int]struct{}
	clearedprintings bool
	done             bool
	oldValue         func(context.Context) (*CardFace, error)
	predicates       []predicate.CardFace
}

var _ ent.Mutation = (*CardFaceMutation)(nil)

// cardfaceOption allows management of the mutation configuration using functional options.
type cardfaceOption func(*CardFaceMutation)

// newCardFaceMutation creates new mutation for the CardFace entity.
func newCardFaceMutation(c config, op Op, opts ...cardfaceOption) *CardFaceMutation {
	m := &CardFaceMutation{
		config:        c,
		op:            op,
		typ:           TypeCardFace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardFaceID sets the ID field of the mutation.
func withCardFaceID(id int) cardfaceOption {
	return func(m *CardFaceMutation) {
		var (
			err   error
			once  sync.Once
			value *CardFace
		)
		m.oldValue = func(ctx context.Context) (*CardFace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CardFace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCardFace sets the old CardFace of the mutation.
func withCardFace(node *CardFace) cardfaceOption {
	return func(m *CardFaceMutation) {
		m.oldValue = func(context.Context) (*CardFace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardFaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardFaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardFaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardFaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CardFace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CardFaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardFaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CardFaceMutation) ResetName() {
	m.name = nil
}

// SetFlavorText sets the "flavor_text" field.
func (m *CardFaceMutation) SetFlavorText(s string) {
	m.flavor_text = &s
}

// FlavorText returns the value of the "flavor_text" field in the mutation.
func (m *CardFaceMutation) FlavorText() (r string, exists bool) {
	v := m.flavor_text
	if v == nil {
		return
	}
	return *v, true
}

// OldFlavorText returns the old "flavor_text" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldFlavorText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlavorText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlavorText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlavorText: %w", err)
	}
	return oldValue.FlavorText, nil
}

// ResetFlavorText resets all changes to the "flavor_text" field.
func (m *CardFaceMutation) ResetFlavorText() {
	m.flavor_text = nil
}

// SetOracleText sets the "oracle_text" field.
func (m *CardFaceMutation) SetOracleText(s string) {
	m.oracle_text = &s
}

// OracleText returns the value of the "oracle_text" field in the mutation.
func (m *CardFaceMutation) OracleText() (r string, exists bool) {
	v := m.oracle_text
	if v == nil {
		return
	}
	return *v, true
}

// OldOracleText returns the old "oracle_text" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldOracleText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOracleText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOracleText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOracleText: %w", err)
	}
	return oldValue.OracleText, nil
}

// ResetOracleText resets all changes to the "oracle_text" field.
func (m *CardFaceMutation) ResetOracleText() {
	m.oracle_text = nil
}

// SetLanguage sets the "language" field.
func (m *CardFaceMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *CardFaceMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *CardFaceMutation) ResetLanguage() {
	m.language = nil
}

// SetCmc sets the "cmc" field.
func (m *CardFaceMutation) SetCmc(f float32) {
	m.cmc = &f
	m.addcmc = nil
}

// Cmc returns the value of the "cmc" field in the mutation.
func (m *CardFaceMutation) Cmc() (r float32, exists bool) {
	v := m.cmc
	if v == nil {
		return
	}
	return *v, true
}

// OldCmc returns the old "cmc" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldCmc(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmc: %w", err)
	}
	return oldValue.Cmc, nil
}

// AddCmc adds f to the "cmc" field.
func (m *CardFaceMutation) AddCmc(f float32) {
	if m.addcmc != nil {
		*m.addcmc += f
	} else {
		m.addcmc = &f
	}
}

// AddedCmc returns the value that was added to the "cmc" field in this mutation.
func (m *CardFaceMutation) AddedCmc() (r float32, exists bool) {
	v := m.addcmc
	if v == nil {
		return
	}
	return *v, true
}

// ResetCmc resets all changes to the "cmc" field.
func (m *CardFaceMutation) ResetCmc() {
	m.cmc = nil
	m.addcmc = nil
}

// SetPower sets the "power" field.
func (m *CardFaceMutation) SetPower(s string) {
	m.power = &s
}

// Power returns the value of the "power" field in the mutation.
func (m *CardFaceMutation) Power() (r string, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldPower(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// ResetPower resets all changes to the "power" field.
func (m *CardFaceMutation) ResetPower() {
	m.power = nil
}

// SetToughness sets the "toughness" field.
func (m *CardFaceMutation) SetToughness(s string) {
	m.toughness = &s
}

// Toughness returns the value of the "toughness" field in the mutation.
func (m *CardFaceMutation) Toughness() (r string, exists bool) {
	v := m.toughness
	if v == nil {
		return
	}
	return *v, true
}

// OldToughness returns the old "toughness" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldToughness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToughness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToughness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToughness: %w", err)
	}
	return oldValue.Toughness, nil
}

// ResetToughness resets all changes to the "toughness" field.
func (m *CardFaceMutation) ResetToughness() {
	m.toughness = nil
}

// SetLoyalty sets the "loyalty" field.
func (m *CardFaceMutation) SetLoyalty(s string) {
	m.loyalty = &s
}

// Loyalty returns the value of the "loyalty" field in the mutation.
func (m *CardFaceMutation) Loyalty() (r string, exists bool) {
	v := m.loyalty
	if v == nil {
		return
	}
	return *v, true
}

// OldLoyalty returns the old "loyalty" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldLoyalty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoyalty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoyalty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoyalty: %w", err)
	}
	return oldValue.Loyalty, nil
}

// ResetLoyalty resets all changes to the "loyalty" field.
func (m *CardFaceMutation) ResetLoyalty() {
	m.loyalty = nil
}

// SetManaCost sets the "mana_cost" field.
func (m *CardFaceMutation) SetManaCost(s string) {
	m.mana_cost = &s
}

// ManaCost returns the value of the "mana_cost" field in the mutation.
func (m *CardFaceMutation) ManaCost() (r string, exists bool) {
	v := m.mana_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldManaCost returns the old "mana_cost" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldManaCost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaCost: %w", err)
	}
	return oldValue.ManaCost, nil
}

// ResetManaCost resets all changes to the "mana_cost" field.
func (m *CardFaceMutation) ResetManaCost() {
	m.mana_cost = nil
}

// SetTypeLine sets the "type_line" field.
func (m *CardFaceMutation) SetTypeLine(s string) {
	m.type_line = &s
}

// TypeLine returns the value of the "type_line" field in the mutation.
func (m *CardFaceMutation) TypeLine() (r string, exists bool) {
	v := m.type_line
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeLine returns the old "type_line" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldTypeLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeLine: %w", err)
	}
	return oldValue.TypeLine, nil
}

// ResetTypeLine resets all changes to the "type_line" field.
func (m *CardFaceMutation) ResetTypeLine() {
	m.type_line = nil
}

// SetColors sets the "colors" field.
func (m *CardFaceMutation) SetColors(s string) {
	m.colors = &s
}

// Colors returns the value of the "colors" field in the mutation.
func (m *CardFaceMutation) Colors() (r string, exists bool) {
	v := m.colors
	if v == nil {
		return
	}
	return *v, true
}

// OldColors returns the old "colors" field's value of the CardFace entity.
// If the CardFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardFaceMutation) OldColors(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColors: %w", err)
	}
	return oldValue.Colors, nil
}

// ResetColors resets all changes to the "colors" field.
func (m *CardFaceMutation) ResetColors() {
	m.colors = nil
}

// SetCardID sets the "card" edge to the Card entity by id.
func (m *CardFaceMutation) SetCardID(id int) {
	m.card = &id
}

// ClearCard clears the "card" edge to the Card entity.
func (m *CardFaceMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *CardFaceMutation) CardCleared() bool {
	return m.clearedcard
}

// CardID returns the "card" edge ID in the mutation.
func (m *CardFaceMutation) CardID() (id int, exists bool) {
	if m.card != nil {
		return *m.card, true
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardID instead. It exists only for internal usage by the builders.
func (m *CardFaceMutation) CardIDs() (ids []int) {
	if id := m.card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *CardFaceMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
}

// AddPrintingIDs adds the "printings" edge to the Printing entity by ids.
func (m *CardFaceMutation) AddPrintingIDs(ids ...int) {
	if m.printings == nil {
		m.printings = make(map[int]struct{})
	}
	for i := range ids {
		m.printings[ids[i]] = struct{}{}
	}
}

// ClearPrintings clears the "printings" edge to the Printing entity.
func (m *CardFaceMutation) ClearPrintings() {
	m.clearedprintings = true
}

// PrintingsCleared reports if the "printings" edge to the Printing entity was cleared.
func (m *CardFaceMutation) PrintingsCleared() bool {
	return m.clearedprintings
}

// RemovePrintingIDs removes the "printings" edge to the Printing entity by IDs.
func (m *CardFaceMutation) RemovePrintingIDs(ids ...int) {
	if m.removedprintings == nil {
		m.removedprintings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.printings, ids[i])
		m.removedprintings[ids[i]] = struct{}{}
	}
}

// RemovedPrintings returns the removed IDs of the "printings" edge to the Printing entity.
func (m *CardFaceMutation) RemovedPrintingsIDs() (ids []int) {
	for id := range m.removedprintings {
		ids = append(ids, id)
	}
	return
}

// PrintingsIDs returns the "printings" edge IDs in the mutation.
func (m *CardFaceMutation) PrintingsIDs() (ids []int) {
	for id := range m.printings {
		ids = append(ids, id)
	}
	return
}

// ResetPrintings resets all changes to the "printings" edge.
func (m *CardFaceMutation) ResetPrintings() {
	m.printings = nil
	m.clearedprintings = false
	m.removedprintings = nil
}

// Where appends a list predicates to the CardFaceMutation builder.
func (m *CardFaceMutation) Where(ps ...predicate.CardFace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CardFaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CardFaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CardFace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CardFaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CardFaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CardFace).
func (m *CardFaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardFaceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, cardface.FieldName)
	}
	if m.flavor_text != nil {
		fields = append(fields, cardface.FieldFlavorText)
	}
	if m.oracle_text != nil {
		fields = append(fields, cardface.FieldOracleText)
	}
	if m.language != nil {
		fields = append(fields, cardface.FieldLanguage)
	}
	if m.cmc != nil {
		fields = append(fields, cardface.FieldCmc)
	}
	if m.power != nil {
		fields = append(fields, cardface.FieldPower)
	}
	if m.toughness != nil {
		fields = append(fields, cardface.FieldToughness)
	}
	if m.loyalty != nil {
		fields = append(fields, cardface.FieldLoyalty)
	}
	if m.mana_cost != nil {
		fields = append(fields, cardface.FieldManaCost)
	}
	if m.type_line != nil {
		fields = append(fields, cardface.FieldTypeLine)
	}
	if m.colors != nil {
		fields = append(fields, cardface.FieldColors)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardFaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cardface.FieldName:
		return m.Name()
	case cardface.FieldFlavorText:
		return m.FlavorText()
	case cardface.FieldOracleText:
		return m.OracleText()
	case cardface.FieldLanguage:
		return m.Language()
	case cardface.FieldCmc:
		return m.Cmc()
	case cardface.FieldPower:
		return m.Power()
	case cardface.FieldToughness:
		return m.Toughness()
	case cardface.FieldLoyalty:
		return m.Loyalty()
	case cardface.FieldManaCost:
		return m.ManaCost()
	case cardface.FieldTypeLine:
		return m.TypeLine()
	case cardface.FieldColors:
		return m.Colors()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardFaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cardface.FieldName:
		return m.OldName(ctx)
	case cardface.FieldFlavorText:
		return m.OldFlavorText(ctx)
	case cardface.FieldOracleText:
		return m.OldOracleText(ctx)
	case cardface.FieldLanguage:
		return m.OldLanguage(ctx)
	case cardface.FieldCmc:
		return m.OldCmc(ctx)
	case cardface.FieldPower:
		return m.OldPower(ctx)
	case cardface.FieldToughness:
		return m.OldToughness(ctx)
	case cardface.FieldLoyalty:
		return m.OldLoyalty(ctx)
	case cardface.FieldManaCost:
		return m.OldManaCost(ctx)
	case cardface.FieldTypeLine:
		return m.OldTypeLine(ctx)
	case cardface.FieldColors:
		return m.OldColors(ctx)
	}
	return nil, fmt.Errorf("unknown CardFace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardFaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cardface.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cardface.FieldFlavorText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlavorText(v)
		return nil
	case cardface.FieldOracleText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOracleText(v)
		return nil
	case cardface.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case cardface.FieldCmc:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmc(v)
		return nil
	case cardface.FieldPower:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	case cardface.FieldToughness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToughness(v)
		return nil
	case cardface.FieldLoyalty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoyalty(v)
		return nil
	case cardface.FieldManaCost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaCost(v)
		return nil
	case cardface.FieldTypeLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeLine(v)
		return nil
	case cardface.FieldColors:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColors(v)
		return nil
	}
	return fmt.Errorf("unknown CardFace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardFaceMutation) AddedFields() []string {
	var fields []string
	if m.addcmc != nil {
		fields = append(fields, cardface.FieldCmc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardFaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cardface.FieldCmc:
		return m.AddedCmc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardFaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cardface.FieldCmc:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCmc(v)
		return nil
	}
	return fmt.Errorf("unknown CardFace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardFaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardFaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardFaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CardFace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardFaceMutation) ResetField(name string) error {
	switch name {
	case cardface.FieldName:
		m.ResetName()
		return nil
	case cardface.FieldFlavorText:
		m.ResetFlavorText()
		return nil
	case cardface.FieldOracleText:
		m.ResetOracleText()
		return nil
	case cardface.FieldLanguage:
		m.ResetLanguage()
		return nil
	case cardface.FieldCmc:
		m.ResetCmc()
		return nil
	case cardface.FieldPower:
		m.ResetPower()
		return nil
	case cardface.FieldToughness:
		m.ResetToughness()
		return nil
	case cardface.FieldLoyalty:
		m.ResetLoyalty()
		return nil
	case cardface.FieldManaCost:
		m.ResetManaCost()
		return nil
	case cardface.FieldTypeLine:
		m.ResetTypeLine()
		return nil
	case cardface.FieldColors:
		m.ResetColors()
		return nil
	}
	return fmt.Errorf("unknown CardFace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardFaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.card != nil {
		edges = append(edges, cardface.EdgeCard)
	}
	if m.printings != nil {
		edges = append(edges, cardface.EdgePrintings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardFaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cardface.EdgeCard:
		if id := m.card; id != nil {
			return []ent.Value{*id}
		}
	case cardface.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.printings))
		for id := range m.printings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardFaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprintings != nil {
		edges = append(edges, cardface.EdgePrintings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardFaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cardface.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.removedprintings))
		for id := range m.removedprintings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardFaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcard {
		edges = append(edges, cardface.EdgeCard)
	}
	if m.clearedprintings {
		edges = append(edges, cardface.EdgePrintings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardFaceMutation) EdgeCleared(name string) bool {
	switch name {
	case cardface.EdgeCard:
		return m.clearedcard
	case cardface.EdgePrintings:
		return m.clearedprintings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardFaceMutation) ClearEdge(name string) error {
	switch name {
	case cardface.EdgeCard:
		m.ClearCard()
		return nil
	}
	return fmt.Errorf("unknown CardFace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardFaceMutation) ResetEdge(name string) error {
	switch name {
	case cardface.EdgeCard:
		m.ResetCard()
		return nil
	case cardface.EdgePrintings:
		m.ResetPrintings()
		return nil
	}
	return fmt.Errorf("unknown CardFace edge %s", name)
}

// PrintingMutation represents an operation that mutates the Printing nodes in the graph.
type PrintingMutation struct {
	config
	op               Op
	typ              string
	id               *int
	rarity           *printing.Rarity
	clearedFields    map[string]struct{}
	artist           *int
	clearedartist    bool
	set              *int
	clearedset       bool
	card_face        *int
	clearedcard_face bool
	images           map[int]struct{}
	removedimages    map[int]struct{}
	clearedimages    bool
	done             bool
	oldValue         func(context.Context) (*Printing, error)
	predicates       []predicate.Printing
}

var _ ent.Mutation = (*PrintingMutation)(nil)

// printingOption allows management of the mutation configuration using functional options.
type printingOption func(*PrintingMutation)

// newPrintingMutation creates new mutation for the Printing entity.
func newPrintingMutation(c config, op Op, opts ...printingOption) *PrintingMutation {
	m := &PrintingMutation{
		config:        c,
		op:            op,
		typ:           TypePrinting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrintingID sets the ID field of the mutation.
func withPrintingID(id int) printingOption {
	return func(m *PrintingMutation) {
		var (
			err   error
			once  sync.Once
			value *Printing
		)
		m.oldValue = func(ctx context.Context) (*Printing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Printing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrinting sets the old Printing of the mutation.
func withPrinting(node *Printing) printingOption {
	return func(m *PrintingMutation) {
		m.oldValue = func(context.Context) (*Printing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrintingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrintingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrintingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrintingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Printing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRarity sets the "rarity" field.
func (m *PrintingMutation) SetRarity(pr printing.Rarity) {
	m.rarity = &pr
}

// Rarity returns the value of the "rarity" field in the mutation.
func (m *PrintingMutation) Rarity() (r printing.Rarity, exists bool) {
	v := m.rarity
	if v == nil {
		return
	}
	return *v, true
}

// OldRarity returns the old "rarity" field's value of the Printing entity.
// If the Printing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintingMutation) OldRarity(ctx context.Context) (v printing.Rarity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRarity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRarity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRarity: %w", err)
	}
	return oldValue.Rarity, nil
}

// ResetRarity resets all changes to the "rarity" field.
func (m *PrintingMutation) ResetRarity() {
	m.rarity = nil
}

// SetArtistID sets the "artist" edge to the Artist entity by id.
func (m *PrintingMutation) SetArtistID(id int) {
	m.artist = &id
}

// ClearArtist clears the "artist" edge to the Artist entity.
func (m *PrintingMutation) ClearArtist() {
	m.clearedartist = true
}

// ArtistCleared reports if the "artist" edge to the Artist entity was cleared.
func (m *PrintingMutation) ArtistCleared() bool {
	return m.clearedartist
}

// ArtistID returns the "artist" edge ID in the mutation.
func (m *PrintingMutation) ArtistID() (id int, exists bool) {
	if m.artist != nil {
		return *m.artist, true
	}
	return
}

// ArtistIDs returns the "artist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtistID instead. It exists only for internal usage by the builders.
func (m *PrintingMutation) ArtistIDs() (ids []int) {
	if id := m.artist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtist resets all changes to the "artist" edge.
func (m *PrintingMutation) ResetArtist() {
	m.artist = nil
	m.clearedartist = false
}

// SetSetID sets the "set" edge to the Set entity by id.
func (m *PrintingMutation) SetSetID(id int) {
	m.set = &id
}

// ClearSet clears the "set" edge to the Set entity.
func (m *PrintingMutation) ClearSet() {
	m.clearedset = true
}

// SetCleared reports if the "set" edge to the Set entity was cleared.
func (m *PrintingMutation) SetCleared() bool {
	return m.clearedset
}

// SetID returns the "set" edge ID in the mutation.
func (m *PrintingMutation) SetID() (id int, exists bool) {
	if m.set != nil {
		return *m.set, true
	}
	return
}

// SetIDs returns the "set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SetID instead. It exists only for internal usage by the builders.
func (m *PrintingMutation) SetIDs() (ids []int) {
	if id := m.set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSet resets all changes to the "set" edge.
func (m *PrintingMutation) ResetSet() {
	m.set = nil
	m.clearedset = false
}

// SetCardFaceID sets the "card_face" edge to the CardFace entity by id.
func (m *PrintingMutation) SetCardFaceID(id int) {
	m.card_face = &id
}

// ClearCardFace clears the "card_face" edge to the CardFace entity.
func (m *PrintingMutation) ClearCardFace() {
	m.clearedcard_face = true
}

// CardFaceCleared reports if the "card_face" edge to the CardFace entity was cleared.
func (m *PrintingMutation) CardFaceCleared() bool {
	return m.clearedcard_face
}

// CardFaceID returns the "card_face" edge ID in the mutation.
func (m *PrintingMutation) CardFaceID() (id int, exists bool) {
	if m.card_face != nil {
		return *m.card_face, true
	}
	return
}

// CardFaceIDs returns the "card_face" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardFaceID instead. It exists only for internal usage by the builders.
func (m *PrintingMutation) CardFaceIDs() (ids []int) {
	if id := m.card_face; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCardFace resets all changes to the "card_face" edge.
func (m *PrintingMutation) ResetCardFace() {
	m.card_face = nil
	m.clearedcard_face = false
}

// AddImageIDs adds the "images" edge to the PrintingImage entity by ids.
func (m *PrintingMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the PrintingImage entity.
func (m *PrintingMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the PrintingImage entity was cleared.
func (m *PrintingMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the PrintingImage entity by IDs.
func (m *PrintingMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the PrintingImage entity.
func (m *PrintingMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *PrintingMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *PrintingMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the PrintingMutation builder.
func (m *PrintingMutation) Where(ps ...predicate.Printing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrintingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrintingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Printing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrintingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrintingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Printing).
func (m *PrintingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrintingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rarity != nil {
		fields = append(fields, printing.FieldRarity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrintingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printing.FieldRarity:
		return m.Rarity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrintingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printing.FieldRarity:
		return m.OldRarity(ctx)
	}
	return nil, fmt.Errorf("unknown Printing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printing.FieldRarity:
		v, ok := value.(printing.Rarity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRarity(v)
		return nil
	}
	return fmt.Errorf("unknown Printing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrintingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrintingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Printing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrintingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrintingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrintingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Printing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrintingMutation) ResetField(name string) error {
	switch name {
	case printing.FieldRarity:
		m.ResetRarity()
		return nil
	}
	return fmt.Errorf("unknown Printing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrintingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artist != nil {
		edges = append(edges, printing.EdgeArtist)
	}
	if m.set != nil {
		edges = append(edges, printing.EdgeSet)
	}
	if m.card_face != nil {
		edges = append(edges, printing.EdgeCardFace)
	}
	if m.images != nil {
		edges = append(edges, printing.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrintingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printing.EdgeArtist:
		if id := m.artist; id != nil {
			return []ent.Value{*id}
		}
	case printing.EdgeSet:
		if id := m.set; id != nil {
			return []ent.Value{*id}
		}
	case printing.EdgeCardFace:
		if id := m.card_face; id != nil {
			return []ent.Value{*id}
		}
	case printing.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrintingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimages != nil {
		edges = append(edges, printing.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrintingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case printing.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrintingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartist {
		edges = append(edges, printing.EdgeArtist)
	}
	if m.clearedset {
		edges = append(edges, printing.EdgeSet)
	}
	if m.clearedcard_face {
		edges = append(edges, printing.EdgeCardFace)
	}
	if m.clearedimages {
		edges = append(edges, printing.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrintingMutation) EdgeCleared(name string) bool {
	switch name {
	case printing.EdgeArtist:
		return m.clearedartist
	case printing.EdgeSet:
		return m.clearedset
	case printing.EdgeCardFace:
		return m.clearedcard_face
	case printing.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrintingMutation) ClearEdge(name string) error {
	switch name {
	case printing.EdgeArtist:
		m.ClearArtist()
		return nil
	case printing.EdgeSet:
		m.ClearSet()
		return nil
	case printing.EdgeCardFace:
		m.ClearCardFace()
		return nil
	}
	return fmt.Errorf("unknown Printing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrintingMutation) ResetEdge(name string) error {
	switch name {
	case printing.EdgeArtist:
		m.ResetArtist()
		return nil
	case printing.EdgeSet:
		m.ResetSet()
		return nil
	case printing.EdgeCardFace:
		m.ResetCardFace()
		return nil
	case printing.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Printing edge %s", name)
}

// PrintingImageMutation represents an operation that mutates the PrintingImage nodes in the graph.
type PrintingImageMutation struct {
	config
	op              Op
	typ             string
	id              *int
	url             *string
	image_type      *printingimage.ImageType
	clearedFields   map[string]struct{}
	printing        *int
	clearedprinting bool
	done            bool
	oldValue        func(context.Context) (*PrintingImage, error)
	predicates      []predicate.PrintingImage
}

var _ ent.Mutation = (*PrintingImageMutation)(nil)

// printingimageOption allows management of the mutation configuration using functional options.
type printingimageOption func(*PrintingImageMutation)

// newPrintingImageMutation creates new mutation for the PrintingImage entity.
func newPrintingImageMutation(c config, op Op, opts ...printingimageOption) *PrintingImageMutation {
	m := &PrintingImageMutation{
		config:        c,
		op:            op,
		typ:           TypePrintingImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrintingImageID sets the ID field of the mutation.
func withPrintingImageID(id int) printingimageOption {
	return func(m *PrintingImageMutation) {
		var (
			err   error
			once  sync.Once
			value *PrintingImage
		)
		m.oldValue = func(ctx context.Context) (*PrintingImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrintingImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrintingImage sets the old PrintingImage of the mutation.
func withPrintingImage(node *PrintingImage) printingimageOption {
	return func(m *PrintingImageMutation) {
		m.oldValue = func(context.Context) (*PrintingImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrintingImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrintingImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrintingImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrintingImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrintingImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *PrintingImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PrintingImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the PrintingImage entity.
// If the PrintingImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintingImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PrintingImageMutation) ResetURL() {
	m.url = nil
}

// SetImageType sets the "image_type" field.
func (m *PrintingImageMutation) SetImageType(pt printingimage.ImageType) {
	m.image_type = &pt
}

// ImageType returns the value of the "image_type" field in the mutation.
func (m *PrintingImageMutation) ImageType() (r printingimage.ImageType, exists bool) {
	v := m.image_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImageType returns the old "image_type" field's value of the PrintingImage entity.
// If the PrintingImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintingImageMutation) OldImageType(ctx context.Context) (v printingimage.ImageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageType: %w", err)
	}
	return oldValue.ImageType, nil
}

// ResetImageType resets all changes to the "image_type" field.
func (m *PrintingImageMutation) ResetImageType() {
	m.image_type = nil
}

// SetPrintingID sets the "printing" edge to the Printing entity by id.
func (m *PrintingImageMutation) SetPrintingID(id int) {
	m.printing = &id
}

// ClearPrinting clears the "printing" edge to the Printing entity.
func (m *PrintingImageMutation) ClearPrinting() {
	m.clearedprinting = true
}

// PrintingCleared reports if the "printing" edge to the Printing entity was cleared.
func (m *PrintingImageMutation) PrintingCleared() bool {
	return m.clearedprinting
}

// PrintingID returns the "printing" edge ID in the mutation.
func (m *PrintingImageMutation) PrintingID() (id int, exists bool) {
	if m.printing != nil {
		return *m.printing, true
	}
	return
}

// PrintingIDs returns the "printing" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrintingID instead. It exists only for internal usage by the builders.
func (m *PrintingImageMutation) PrintingIDs() (ids []int) {
	if id := m.printing; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrinting resets all changes to the "printing" edge.
func (m *PrintingImageMutation) ResetPrinting() {
	m.printing = nil
	m.clearedprinting = false
}

// Where appends a list predicates to the PrintingImageMutation builder.
func (m *PrintingImageMutation) Where(ps ...predicate.PrintingImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrintingImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrintingImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrintingImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrintingImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrintingImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrintingImage).
func (m *PrintingImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrintingImageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.url != nil {
		fields = append(fields, printingimage.FieldURL)
	}
	if m.image_type != nil {
		fields = append(fields, printingimage.FieldImageType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrintingImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printingimage.FieldURL:
		return m.URL()
	case printingimage.FieldImageType:
		return m.ImageType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrintingImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printingimage.FieldURL:
		return m.OldURL(ctx)
	case printingimage.FieldImageType:
		return m.OldImageType(ctx)
	}
	return nil, fmt.Errorf("unknown PrintingImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintingImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printingimage.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case printingimage.FieldImageType:
		v, ok := value.(printingimage.ImageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageType(v)
		return nil
	}
	return fmt.Errorf("unknown PrintingImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrintingImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrintingImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintingImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrintingImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrintingImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrintingImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrintingImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PrintingImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrintingImageMutation) ResetField(name string) error {
	switch name {
	case printingimage.FieldURL:
		m.ResetURL()
		return nil
	case printingimage.FieldImageType:
		m.ResetImageType()
		return nil
	}
	return fmt.Errorf("unknown PrintingImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrintingImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.printing != nil {
		edges = append(edges, printingimage.EdgePrinting)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrintingImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printingimage.EdgePrinting:
		if id := m.printing; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrintingImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrintingImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrintingImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprinting {
		edges = append(edges, printingimage.EdgePrinting)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrintingImageMutation) EdgeCleared(name string) bool {
	switch name {
	case printingimage.EdgePrinting:
		return m.clearedprinting
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrintingImageMutation) ClearEdge(name string) error {
	switch name {
	case printingimage.EdgePrinting:
		m.ClearPrinting()
		return nil
	}
	return fmt.Errorf("unknown PrintingImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrintingImageMutation) ResetEdge(name string) error {
	switch name {
	case printingimage.EdgePrinting:
		m.ResetPrinting()
		return nil
	}
	return fmt.Errorf("unknown PrintingImage edge %s", name)
}

// RulingMutation represents an operation that mutates the Ruling nodes in the graph.
type RulingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	text          *string
	date          *time.Time
	clearedFields map[string]struct{}
	card          *int
	clearedcard   bool
	done          bool
	oldValue      func(context.Context) (*Ruling, error)
	predicates    []predicate.Ruling
}

var _ ent.Mutation = (*RulingMutation)(nil)

// rulingOption allows management of the mutation configuration using functional options.
type rulingOption func(*RulingMutation)

// newRulingMutation creates new mutation for the Ruling entity.
func newRulingMutation(c config, op Op, opts ...rulingOption) *RulingMutation {
	m := &RulingMutation{
		config:        c,
		op:            op,
		typ:           TypeRuling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRulingID sets the ID field of the mutation.
func withRulingID(id int) rulingOption {
	return func(m *RulingMutation) {
		var (
			err   error
			once  sync.Once
			value *Ruling
		)
		m.oldValue = func(ctx context.Context) (*Ruling, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ruling.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuling sets the old Ruling of the mutation.
func withRuling(node *Ruling) rulingOption {
	return func(m *RulingMutation) {
		m.oldValue = func(context.Context) (*Ruling, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RulingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RulingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RulingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RulingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ruling.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *RulingMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *RulingMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Ruling entity.
// If the Ruling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulingMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *RulingMutation) ResetText() {
	m.text = nil
}

// SetDate sets the "date" field.
func (m *RulingMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *RulingMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Ruling entity.
// If the Ruling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulingMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *RulingMutation) ResetDate() {
	m.date = nil
}

// SetCardID sets the "card" edge to the Card entity by id.
func (m *RulingMutation) SetCardID(id int) {
	m.card = &id
}

// ClearCard clears the "card" edge to the Card entity.
func (m *RulingMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *RulingMutation) CardCleared() bool {
	return m.clearedcard
}

// CardID returns the "card" edge ID in the mutation.
func (m *RulingMutation) CardID() (id int, exists bool) {
	if m.card != nil {
		return *m.card, true
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardID instead. It exists only for internal usage by the builders.
func (m *RulingMutation) CardIDs() (ids []int) {
	if id := m.card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *RulingMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
}

// Where appends a list predicates to the RulingMutation builder.
func (m *RulingMutation) Where(ps ...predicate.Ruling) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RulingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RulingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ruling, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RulingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RulingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ruling).
func (m *RulingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RulingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.text != nil {
		fields = append(fields, ruling.FieldText)
	}
	if m.date != nil {
		fields = append(fields, ruling.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RulingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ruling.FieldText:
		return m.Text()
	case ruling.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RulingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ruling.FieldText:
		return m.OldText(ctx)
	case ruling.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Ruling field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ruling.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case ruling.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Ruling field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RulingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RulingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ruling numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RulingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RulingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RulingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ruling nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RulingMutation) ResetField(name string) error {
	switch name {
	case ruling.FieldText:
		m.ResetText()
		return nil
	case ruling.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Ruling field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RulingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.card != nil {
		edges = append(edges, ruling.EdgeCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RulingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ruling.EdgeCard:
		if id := m.card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RulingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RulingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RulingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcard {
		edges = append(edges, ruling.EdgeCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RulingMutation) EdgeCleared(name string) bool {
	switch name {
	case ruling.EdgeCard:
		return m.clearedcard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RulingMutation) ClearEdge(name string) error {
	switch name {
	case ruling.EdgeCard:
		m.ClearCard()
		return nil
	}
	return fmt.Errorf("unknown Ruling unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RulingMutation) ResetEdge(name string) error {
	switch name {
	case ruling.EdgeCard:
		m.ResetCard()
		return nil
	}
	return fmt.Errorf("unknown Ruling edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	code             *string
	clearedFields    map[string]struct{}
	printings        map[int]struct{}
	removedprintings map[int]struct{}
	clearedprintings bool
	done             bool
	oldValue         func(context.Context) (*Set, error)
	predicates       []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("bones: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SetMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *SetMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SetMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SetMutation) ResetCode() {
	m.code = nil
}

// AddPrintingIDs adds the "printings" edge to the Printing entity by ids.
func (m *SetMutation) AddPrintingIDs(ids ...int) {
	if m.printings == nil {
		m.printings = make(map[int]struct{})
	}
	for i := range ids {
		m.printings[ids[i]] = struct{}{}
	}
}

// ClearPrintings clears the "printings" edge to the Printing entity.
func (m *SetMutation) ClearPrintings() {
	m.clearedprintings = true
}

// PrintingsCleared reports if the "printings" edge to the Printing entity was cleared.
func (m *SetMutation) PrintingsCleared() bool {
	return m.clearedprintings
}

// RemovePrintingIDs removes the "printings" edge to the Printing entity by IDs.
func (m *SetMutation) RemovePrintingIDs(ids ...int) {
	if m.removedprintings == nil {
		m.removedprintings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.printings, ids[i])
		m.removedprintings[ids[i]] = struct{}{}
	}
}

// RemovedPrintings returns the removed IDs of the "printings" edge to the Printing entity.
func (m *SetMutation) RemovedPrintingsIDs() (ids []int) {
	for id := range m.removedprintings {
		ids = append(ids, id)
	}
	return
}

// PrintingsIDs returns the "printings" edge IDs in the mutation.
func (m *SetMutation) PrintingsIDs() (ids []int) {
	for id := range m.printings {
		ids = append(ids, id)
	}
	return
}

// ResetPrintings resets all changes to the "printings" edge.
func (m *SetMutation) ResetPrintings() {
	m.printings = nil
	m.clearedprintings = false
	m.removedprintings = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Set, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, set.FieldName)
	}
	if m.code != nil {
		fields = append(fields, set.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldName:
		return m.Name()
	case set.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldName:
		return m.OldName(ctx)
	case set.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case set.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldName:
		m.ResetName()
		return nil
	case set.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.printings != nil {
		edges = append(edges, set.EdgePrintings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.printings))
		for id := range m.printings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprintings != nil {
		edges = append(edges, set.EdgePrintings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgePrintings:
		ids := make([]ent.Value, 0, len(m.removedprintings))
		for id := range m.removedprintings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprintings {
		edges = append(edges, set.EdgePrintings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgePrintings:
		return m.clearedprintings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgePrintings:
		m.ResetPrintings()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}
